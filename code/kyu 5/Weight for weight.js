function orderWeight(strng) {
        const weightsArr = strng.trim().split(/\s+/);

        function sumDigits(num) {
            return num.split('').reduce((acc, digit) => acc + parseInt(digit), 0);
        }

        weightsArr.sort((a, b) => {
            const sumA = sumDigits(a);
            const sumB = sumDigits(b);

            if (sumA === sumB) {
                return a.localeCompare(b);
            } else {
                return sumA - sumB;
            }
        });

        // Join the sorted array back into a string and return it
        return weightsArr.join(' ');


    // your code
}

console.log( orderWeight("56 65 74 100 99 68 86 180 90")) //"100 180 90 56 65 74 68 86 99"
console.log( orderWeight("2000 10003 1234000 44444444 9999 11 11 22 123"))//"11 11 2000 10003 22 123 1234000 44444444 9999"))

// Test.assertEquals(orderWeight("103 123 4444 99 2000"), "2000 103 123 4444 99")
//     Test.assertEquals(orderWeight("2000 10003 1234000 44444444 9999 11 11 22 123"), "11 11 2000 10003 22 123 1234000 44444444 9999")

//Мой друг Джон и я являемся членами «Fat to Fit Club (FFC)». Джон беспокоится, потому что каждый месяц публикуется список с весами участников, и каждый месяц он последний в списке, что означает, что он самый тяжелый.
//
// Я тот, кто составляет список, поэтому я сказал ему: «Не волнуйся больше, я изменю порядок списка». Было решено приписать числам «вес». Отныне вес числа будет равен сумме его цифр.
//
// Например 99будет иметь "вес" 18, 100будет иметь "вес" 1так что в списке 100будет стоять раньше 99.
//
// Учитывая строку с весами членов FFC в нормальном порядке, можете ли вы отсортировать эту строку по «весам» этих чисел?
//
// Пример:
// "56 65 74 100 99 68 86 180 90" ordered by numbers weights becomes:
//
// "100 180 90 56 65 74 68 86 99"
// Когда два числа имеют одинаковый «вес», давайте классифицируем их так, как если бы они были строками (в алфавитном порядке), а не числами:
//
// 180находится раньше 90, так как, имея тот же «вес» (9), он стоит перед строкой .
//
// Все числа в списке положительные, и список может быть пустым.
//
// Заметки
// может случиться так, что во входной строке есть начальные, конечные пробелы и более чем уникальный пробел между двумя последовательными числами.
// Для C: результат освобождается.