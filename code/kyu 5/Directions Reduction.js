function dirReduc(arr){
    const oppositeDirections = {
        NORTH: 'SOUTH',
        SOUTH: 'NORTH',
        EAST: 'WEST',
        WEST: 'EAST'
    };

    const simplifiedArr = [];

    for (const direction of arr) {
        const lastDirection = simplifiedArr[simplifiedArr.length - 1];

        if (lastDirection && lastDirection === oppositeDirections[direction]) {
            simplifiedArr.pop();
        } else {
            simplifiedArr.push(direction);
        }
    }

    return simplifiedArr;

}

//it("test", () => {
// 		doTest(
// 			["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"],
// 			["WEST"]
// 		);
// 		doTest(
// 			["NORTH", "WEST", "SOUTH", "EAST"],
// 			["NORTH", "WEST", "SOUTH", "EAST"]
// 		);
// 		doTest(
// 			["NORTH", "SOUTH", "EAST", "WEST", "EAST", "WEST"],
// 			[]
// 		);


//Однажды, на пути через старый дикий горный запад,…
// …человеку дали указание пройти из одной точки в другую. Направления были «СЕВЕР», «ЮГ», «ЗАПАД», «ВОСТОК». Ясно, что "СЕВЕР" и "ЮГ" противоположны, "ЗАПАД" и "ВОСТОК" тоже.
//
// Идти в одном направлении и сразу же возвращаться в противоположном направлении — бесполезное усилие. Поскольку это дикий запад, с ужасной погодой и небольшим количеством воды, важно экономить силы, иначе вы можете умереть от жажды!
//
// Как я ловко пересек горную пустыню.
// Указания, данные мужчине, например, следующие (в зависимости от языка):
//
// ["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"].
// or
// { "NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST" };
// or
// [North, South, South, East, West, North, West]
// Сразу видно, что идти "НА СЕВЕР" и сразу "ЮГ" нецелесообразно, лучше оставайтесь на том же месте! Итак, задача состоит в том, чтобы дать человеку упрощённый вариант плана. Лучший план в этом случае просто:
//
// ["WEST"]
// or
// { "WEST" }
// or
// [West]
// Другие примеры:
// В ["NORTH", "SOUTH", "EAST", "WEST"], направление "NORTH" + "SOUTH"идет на север и сразу же возвращается .
//
// Путь становится ["EAST", "WEST"], теперь "EAST"и "WEST"уничтожают друг друга, поэтому конечный результат [](ноль в Clojure).
//
// В ["СЕВЕР", "ВОСТОК", "ЗАПАД", "ЮГ", "ЗАПАД", "ЗАПАД"] "СЕВЕР" и "ЮГ" не являются прямо противоположными, но они становятся прямо противоположными после сокращения " ВОСТОК " и "ЗАПАД", поэтому весь путь можно свести к ["ЗАПАД", "ЗАПАД"].
//
// Задача
// Напишите функцию dirReduc, которая будет принимать массив строк и возвращать массив строк с удаленными ненужными направлениями (W<->E или S<->N рядом ).
//
// Версия Haskell принимает список направлений с расширением data Direction = North | East | West | South.
// Версия Clojure возвращает nil, когда путь сводится к нулю.
// Версия Rust занимает часть enum Direction {North, East, West, South}.
// Дополнительные примеры см. в разделе «Примеры тестов».
// Заметки
// Не все пути можно сделать проще. Путь ["СЕВЕР", "ЗАПАД", "ЮГ", "ВОСТОК"] не сводим. «СЕВЕР» и «ЗАПАД», «ЗАПАД» и «ЮГ», «ЮГ» и «ВОСТОК» не являются прямо противоположными друг другу и не могут стать таковыми. Следовательно, путь результата сам по себе: ["СЕВЕР", "ЗАПАД", "ЮГ", "ВОСТОК"].
// если вы хотите перевести, пожалуйста, спросите, прежде чем переводить.