function getPINs(observed) {
    const adjacentDigits = {
        "1": ["1", "2", "4"],
        "2": ["1", "2", "3", "5"],
        "3": ["2", "3", "6"],
        "4": ["1", "4", "5", "7"],
        "5": ["2", "4", "5", "6", "8"],
        "6": ["3", "5", "6", "9"],
        "7": ["4", "7", "8"],
        "8": ["5", "7", "8", "9", "0"],
        "9": ["6", "8", "9"],
        "0": ["0", "8"]
    };

    const variations=(digits)=>{
        if(digits.length===1){
            return adjacentDigits[digits]
        }
       // console.log('digits1',digits)
        const rest=variations(digits.slice(1))
       // console.log('digits2',digits)
        //console.log('rest',rest)
       // console.log('d',adjacentDigits[digits[0]])
        return adjacentDigits[digits[0]]
            .map((digit)=>rest.map((variation)=>digit+variation))
            .reduce((a,b)=>a.concat(b),[])
    }
    return variations(observed)
}

//V2
/*function getPINs(observed) {
    return observed.split('')
        .map( t => ({
            '0': [ '0', '8' ],
            '1': [ '1', '2', '4' ],
            '2': [ '1', '2', '3', '5' ],
            '3': [ '2', '3', '6' ],
            '4': [ '1', '4', '5', '7' ],
            '5': [ '2', '4', '5', '6', '8' ],
            '6': [ '3', '5', '6', '9' ],
            '7': [ '4', '7', '8' ],
            '8': [ '5', '7', '8', '9', '0' ],
            '9': [ '6', '8', '9' ]
        }[t]))
        .reduce((pre, cur)=> [].concat.apply([], pre.map(t => cur.map(g => t + g))));
}*/



//console.log(getPINs('7'))
//console.log(getPINs('5'))
//console.log(getPINs('11'))
//console.log(getPINs('56'))
console.log(getPINs('369'))
//Итак, детектив, один из наших коллег успешно обнаружил нашу цель, грабителя Робби. Следуем за ним на секретный склад, где предполагаем найти все украденное. Дверь в этот склад защищена электронным кодовым замком. К сожалению, наш шпион не уверен в ПИН-коде, который он видел, когда Робби ввел его.
//
// Клавиатура имеет следующую компоновку:
//
// ┌───┬───┬───┐
// │ 1 │ 2 │ 3 │
// ├───┼───┼───┤
// │ 4 │ 5 │ 6 │
// ├───┼───┼───┤
// │ 7 │ 8 │ 9 │
// └───┼───┼───┘
//     │ 0 │
//     └───┘
// Он отметил PIN-код 1357, но также сказал, что возможно, что каждая из цифр, которые он видел, на самом деле может быть другой соседней цифрой (по горизонтали или вертикали, но не по диагонали). Например, вместо этого 1также может быть 2или 4. А вместо , 5это может быть 2, 4, 6или 8.
//
// Он также упомянул, что знает такие замки. Вы можете ввести неограниченное количество неправильных PIN-кодов, они никогда не заблокируют систему окончательно и не подадут сигнал тревоги. Вот почему мы можем попробовать все возможные (*) варианты.
//
// * возможно в смысле: самого наблюдаемого PIN-кода и всех вариаций с учетом соседних цифр
//
// Можете ли вы помочь нам найти все эти варианты? Было бы неплохо иметь функцию, которая возвращает массив (или список в Java/Kotlin и C#) всех вариантов наблюдаемого PIN-кода длиной от 1 до 8 цифр. Мы могли бы назвать функцию getPINs( get_pinsв python, GetPINsв C#). Но обратите внимание, что все PIN-коды, как наблюдаемые, так и результаты, должны быть строками из-за потенциально ведущих нулей. Мы уже подготовили для вас несколько тестовых случаев.
//
// Детектив, мы рассчитываем на вас!


//const { assert, config} = require('chai');
//
// config.truncateThreshold = 0;
//
// describe('example tests', function() {
//
//   let expectations = {
//     "8": ["5", "7", "8", "9", "0"],
//     "11": ["11", "22", "44", "12", "21", "14", "41", "24", "42"],
//     "369": ["339","366","399","658","636","258","268","669","668","266","369","398","256","296","259","368","638","396","238","356","659","639","666","359","336","299","338","696","269","358","656","698","699","298","236","239"]
//   };
//
//   for (let pin in expectations) {
//
//     it(`Testing PIN='${pin}'`, () => {
//       assert.sameMembers(getPINs(pin), expectations[pin]);
//     });
//   }
// });